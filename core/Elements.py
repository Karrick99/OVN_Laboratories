#
import json
import math
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import sys
import core.constants as const
import random

from scipy.special import erfcinv


class Signal_information:
    def __init__(self, signal_power, path):
        self.signal_power = signal_power
        self.noise_power = 0.0
        self.latency = 0.0
        self.path: str = path

    def update_pwr(self, signal_pwr):
        self.signal_power = signal_pwr

    def update_noise(self, noise_pwr_incr):
        self.noise_power = self.noise_power + noise_pwr_incr

    def update_latency(self, latency_incr):
        self.latency = self.latency + latency_incr

    def update_path(self):
        self.path = self.path[1:]

    def get_path(self):
        return self.path


class Lightpath(Signal_information):
    def __init__(self, signal_power, path, channel):
        super().__init__(signal_power, path)
        self.channel = channel
        self.Rs = const.Rs
        self.df = const.df


class Node:
    def __init__(self, key, d):
        self.label = key
        self.position = d['position'][:]
        self.connected_nodes = d['connected_nodes'][:]
        self.successive = {}
        self.switching_matrix = None
        if 'transceiver' in d:
            self.transceiver = d['transceiver']
        else:
            self.transceiver = 'fixed_rate'

    def propagate(self, lightpath_obj, occupation=False):
        """propagates the signal to the end of the path"""
        if len(lightpath_obj.path) > 1:
            line_label = lightpath_obj.path[0] + lightpath_obj.path[1]
            lightpath_obj.update_path()
            next_line = self.successive[line_label]
            lightpath_obj.update_pwr(next_line.optimized_launch_power())
            lightpath_obj = next_line.propagate(lightpath_obj, occupation)
        return lightpath_obj

    def get_position(self):
        return self.position

    def get_connected_nodes(self):
        return self.connected_nodes

    def set_successive(self, line_label, line_obj):
        self.successive[line_label] = line_obj

    def get_successive(self, line_label):
        return self.successive[line_label]


class Line:
    """Connection between two nodes"""

    def __init__(self, label, length):
        self.label = label
        self.length = length
        self.successive = {}
        self.state = ['free'] * const.Nch  # Nch is the number of channels
        self.n_amplifiers = int(length / 8e4)

        # constants:

        self.Bn = const.Bn
        self.f = const.f

        self.gain = const.gain
        self.noise_figure = const.noise_figure
        self.alphadB = const.alphadB
        self.alpha = self.alphadB / (20 * np.log10(np.e))
        self.Leff = 1 / (2 * self.alpha)
        self.L = 10**((self.alphadB*8e4)/10)
        self.beta2 = const.beta2
        self.gamma = const.gamma
        self.Rs = const.Rs
        self.df = const.df
        self.Pbase = const.h * self.f * self.df

        self.eta_nli = (16 / (27 * np.pi)) * np.log10(
            ((np.pi ** 2) / 2) * (np.abs(self.beta2) * self.Rs ** 2 / self.alpha) * (const.Nch ** (2 * self.Rs / self.df))) \
                       * ((self.gamma ** 2 / (4 * self.alpha * self.beta2)) / (self.Rs ** 3))


    def set_successive(self, node_label, node_obj):
        self.successive[node_label] = node_obj

    def set_free(self, channel):
        self.state[channel] = 'free'

    def set_occupied(self, channel):
        self.state[channel] = 'occupied'

    def is_free(self, channel):
        return self.state[channel] == 'free'

    def latency_generation(self):
        t = self.length / (const.c * 2 / 3)
        return t

    def noise_generation(self):
        return self.nli_generation() + self.ase_generation()

    def propagate(self, lightpath_obj, occupation=False):
        # latency and noise update
        lightpath_obj.update_latency(self.latency_generation())
        lightpath_obj.update_noise(self.noise_generation())
        # successive node, propagate
        next_node = self.successive[lightpath_obj.path[0]]
        lightpath_obj = next_node.propagate(lightpath_obj)

        # update line state
        if occupation:
            channel = lightpath_obj.channel
            self.set_occupied(channel)

        return lightpath_obj

    def ase_generation(self):
        """returns total amount of amplified spontaneous emissions"""
        return self.n_amplifiers * const.h * self.f * self.Bn * self.noise_figure * (self.gain - 1)

    def nli_generation(self):
        """returns the total amount generated by the nonlinear interference"""

        return (self.optimized_launch_power()**3) * self.eta_nli * self.n_amplifiers * const.Bn

    def optimized_launch_power(self):
        """returns the optimal power for the line in order to maximize SNR"""

        return ((self.noise_figure * self.L * self.Pbase) / (2 * self.df * self.eta_nli)) ** (1 / 3)


class Network:
    def __init__(self):
        self.nodes = {}
        self.lines = {}
        self.weighted_paths = None
        self.route_space = None
        self.rejected_connections = 0
        self.total_possible_connections = 0

        # with open("nodes.json", "r") as in_file:
        with open(const.filename, "r") as in_file:
            data = json.load(in_file)

        for key in data:
            self.nodes[key] = Node(key, data[key])

        for key in self.nodes:
            for target in self.nodes[key].get_connected_nodes():
                self.lines[key + target] = Line(key + target,
                                                self.__distance(self.nodes[key].get_position(),
                                                                self.nodes[target].get_position()))

        # creation of the pandas dataframe:

        path_sep = "->"
        tab = []

        self.connect()

        columns_list = ["path", "total latency", "total noise", "SNR [dB]", "GSNR"]

        for key1 in self.nodes:
            for key2 in self.nodes:
                if key1 != key2:
                    for p in self.find_paths(key1, key2):
                        total_latency = 0
                        total_noise = 0
                        isnr = 0

                        # for every line in path, add its latency and noise
                        for i in range(len(p) - 1):
                            line_temp = self.nodes[p[i]].get_successive(p[i] + p[i + 1])
                            total_latency += line_temp.latency_generation()
                            total_noise += line_temp.noise_generation()

                            # SNR CALCULATION
                            isnr += line_temp.noise_generation() / line_temp.optimized_launch_power()

                        gsnr = 1 / isnr
                        snr = 10 * np.log10(gsnr)

                        # OLD SNR CALCULATION
                        # if total_noise != 0:
                        # gsnr = 1e-3 / total_noise
                        # snr = 10 * np.log10(gsnr)

                        temp_row = [path_sep.join(p), total_latency, total_noise, snr, gsnr]
                        tab.append(temp_row)

        self.weighted_paths = pd.DataFrame(tab, columns=columns_list)

        # ROUTE_SPACE CREATION:

        self.route_space = pd.DataFrame(columns=['path'] + [str(i) for i in range(const.Nch)])
        self.route_space.path = self.weighted_paths.path
        self.route_space.fillna('free', inplace=True)

        self.total_possible_connections = self.route_space.shape[0] * (self.route_space.shape[1]-1)

    def __distance(self, pos1, pos2):
        """returns the distance between two tuples"""

        dist = math.sqrt((pos2[0] - pos1[0]) ** 2 + (pos2[1] - pos1[1]) ** 2)
        return dist

    def connect(self):
        """sets the 'successive' attribute of nodes and lines as a dictionary"""

        for key1 in self.nodes:
            n = self.nodes[key1]
            n.switching_matrix = dict()

            for key2 in n.connected_nodes:
                n.set_successive(key1 + key2, self.lines[key1 + key2])
                self.lines[key1 + key2].set_successive(key2, self.nodes[key2])
                # task lab 6:
                # add the current element
                n.switching_matrix.update({key2: {key2: [0] * 10}})
                for key in n.switching_matrix:
                    if key != key2:
                        n.switching_matrix[key2].update({key: [1] * 10})
                        n.switching_matrix[key].update({key2: [1] * 10})

            # print(n.switching_matrix)
            # print("\n")

    def paths_search(self, target, stack, paths):
        """recursive function to search all the possible paths between two nodes"""

        current = self.nodes[stack[-1]]
        if current.label != target:
            for n in current.connected_nodes:
                if n not in stack:
                    stack.append(n)
                    self.paths_search(target, stack, paths)
                    stack.pop()
        else:
            new_path = stack[:]
            paths.append(new_path)
            return

        return

    def find_paths(self, src, target):
        """returns the list of all paths between s1 and s2"""
        paths = []
        stack = [src]

        if target not in self.nodes.keys():
            return paths

        self.paths_search(target, stack, paths)
        return paths

    def propagate(self, signal_inf_obj):
        """Propagates the signal_information object through path """
        path_to_propagate: str = signal_inf_obj.get_path()
        label = path_to_propagate[0]

        return self.nodes[label].propagate(signal_inf_obj)

    def draw(self):
        """Plots the network as points and lines"""

        for key in self.lines:
            nodes_string = self.lines[key].label
            n1 = nodes_string[0]
            n2 = nodes_string[1]
            xvals = self.nodes[n1].get_position()[0], self.nodes[n2].get_position()[0]
            yvals = self.nodes[n1].get_position()[1], self.nodes[n2].get_position()[1]
            plt.plot(xvals, yvals, color='green', linewidth=2, markersize=12, zorder=1)

            # arrow:
            if n2 in self.nodes[n1].connected_nodes:
                # arrow from n1 to n2
                plt.arrow(xvals[0], yvals[0], (xvals[1]-xvals[0])/5, (yvals[1]-yvals[0])/5, linewidth=4,
                          color='blue', zorder=2, shape='full')
            if n1 in self.nodes[n2].connected_nodes:
                # arrow from n2 to n1
                plt.arrow(xvals[1], yvals[1], (xvals[0] - xvals[1]) / 5, (yvals[0] - yvals[1]) / 5, linewidth=4,
                          color='blue', zorder=3, shape='full')

        for key in self.nodes:
            x, y = self.nodes[key].get_position()
            plt.plot(x, y, 'ro', zorder=4, markersize=12)
            plt.annotate(text=self.nodes[key].label, xy=(x, y), xytext=(x + 10000, y + 10000), color='red', size=20)

        plt.xlabel('x [m]')
        plt.ylabel('y [m]')
        plt.grid()
        plt.show()

    def find_best_snr(self, input_node, output_node):
        """Returns the path with highest SNR from input_node to output_node"""
        paths = self.weighted_paths.path.values
        best_snr = 0.0
        best_snr_path = ""

        for p_df in paths:
            p = p_df.replace('->', '')
            if p[0] == input_node and p[-1] == output_node:
                current_snr = self.weighted_paths.loc[self.weighted_paths['path'] == p_df]['SNR [dB]'].values[0]
                if 'free' in self.route_space[self.route_space['path'] == p_df].values:
                    if current_snr > best_snr:
                        best_snr = current_snr
                        best_snr_path = p

        return best_snr_path

    def find_best_latency(self, input_node, output_node):
        # migliorabile/ottimizzabile
        """Returns the path with lowest latency from input_node to output_node"""
        paths = self.weighted_paths.path.values

        best_latency = sys.float_info.max

        best_latency_path = ""
        for p_df in paths:
            p = p_df.replace('->', '')
            if p[0] == input_node and p[-1] == output_node:
                current_latency = self.weighted_paths.loc[self.weighted_paths['path'] == p_df]['total latency'].values[
                    0]
                if 'free' in self.route_space[self.route_space['path'] == p_df].values:

                    if current_latency < best_latency:
                        best_latency = current_latency
                        best_latency_path = p

        return best_latency_path

    def stream(self, connections_list, parameter='latency'):
        """Streams a list of connections choosing their paths for snr or latency"""

        processed_conn = []
        for conn in connections_list:
            input_node = conn.input
            output_node = conn.output
            signal_power = conn.signal_power

            if parameter == 'snr':
                path = self.find_best_snr(input_node, output_node)
            elif parameter == 'latency':
                path = self.find_best_latency(input_node, output_node)
            else:
                print("Parameter not recognized (it should be 'snr' or 'latency')")
                return []


            if len(path) > 1:
                # calculation of the bit rate
                path_df = self.reformat_path(path)
                path_occupation_list = self.route_space.loc[self.route_space['path'] == path_df].values[0][1:]
                free_channel = [i for i in range(len(path_occupation_list)) if path_occupation_list[i] == 'free'][0]
                input_lightpath = Lightpath(signal_power, path, free_channel)
                conn.bit_rate = self.calculate_bit_rate(input_lightpath, self.nodes[path[0]].transceiver)

                if conn.bit_rate > 0:
                    # take the first free channel in route_space:

                    output_lightpath = self.propagate(input_lightpath)
                    conn.latency = output_lightpath.latency

                    # TAKE SNR FROM THE DATAFRAME
                    conn.snr = self.weighted_paths[self.weighted_paths.path == path_df]['SNR [dB]'].values[0]
                    conn.gsnr = self.weighted_paths[self.weighted_paths.path == path_df]['GSNR'].values[0]

                    # set the used channel as occupied for the paths with lines in common

                    self.occupy_channel(path, free_channel)

                    # evaluation of occupation percentage

                    processed_conn.append(conn)


                else:
                    # case of refused connection
                    conn.latency = None
                    conn.snr = 0.0
                    # decide if put here an error message
            else:
                self.rejected_connections += 1

        return processed_conn

    def reformat_path(self, path):
        path_list = [str(i + '->') for i in path[:-1]] + [path[-1]]
        path_string = ''
        return path_string.join(path_list)

    def occupy_channel(self, path, free_channel):
        """Occupies the channel in current path and every path that with lines in common"""
        path_df_1 = self.reformat_path(path)

        # control of every path in order to find common lines:

        for path_df_2 in self.route_space.path.values:
            if self.intersection_lines(path_df_1, path_df_2):
                # devo settare come occupato il canale
                row = self.route_space[self.route_space['path'] == path_df_2].values
                row[0][free_channel + 1] = "occupied"
                self.route_space[self.route_space['path'] == path_df_2] = row

    def intersection_lines(self, path1, path2):
        """returns True if there is a line in common between two paths"""
        # the paths are passed as string with the separator '->'
        lines_list_1 = [path1[i * 3: i * 3 + 4] for i in range(len(path1) // 3)]
        lines_list_2 = [path2[i * 3: i * 3 + 4] for i in range(len(path2) // 3)]

        for l1 in lines_list_1:
            for l2 in lines_list_2:
                if l1 == l2:
                    return True

        return False

    def calculate_bit_rate(self, lightpath: Lightpath, strategy):
        """Calculates bit rate of a lightpath by GSNR and the strategy"""
        path = lightpath.path
        path_df = self.reformat_path(path)
        gsnr = self.weighted_paths[self.weighted_paths.path == path_df]['GSNR'].values[0]

        if strategy == 'fixed_rate':
            if gsnr >= 2 * ((erfcinv(2e-3)) ** 2) * lightpath.Rs / const.Bn:
                return 100e9
            else:
                return 0

        if strategy == 'flex_rate':

            if gsnr < 2 * ((erfcinv(2e-3)) ** 2) * (lightpath.Rs / const.Bn):
                return 0
            elif 2 * ((erfcinv(2e-3)) ** 2) * lightpath.Rs / const.Bn <= gsnr < (14 / 3) * (
                    (erfcinv((3 / 2) * 1e-3)) ** 2) * lightpath.Rs / const.Bn:
                return 100e9
            elif (14 / 3) * ((erfcinv((3 / 2) * 1e-3)) ** 2) * lightpath.Rs / const.Bn <= gsnr < 10 * (
                    (erfcinv((8 / 3) * 1e-3)) ** 2) * lightpath.Rs / const.Bn:
                return 200e9
            elif gsnr > 10 * ((erfcinv((8 / 3) * 1e-3)) ** 2) * lightpath.Rs / const.Bn:
                return 400e9

        if strategy == 'shannon':
            return 2 * lightpath.Rs * np.log2(1 + (const.Bn / lightpath.Rs) * gsnr)

    def manage_connection_from_traffic_matrix(self, traffic_matrix):
        """Given a traffic matrix, creates connections"""
        nonzero = traffic_matrix.to_numpy().nonzero()
        processed_conn_list = []
        while len(nonzero[0]) > 0:
            node_names = list(traffic_matrix.columns)

            req = random.randint(0, len(nonzero[0]) - 1)

            i = node_names[nonzero[0][req]]
            j = node_names[nonzero[1][req]]

            if np.isinf(traffic_matrix.at[i, j]):
                # case of infinite request of capacity: I allocate the possible capacity
                while True:
                    conn = Connection(i, j, 1)
                    processed_conn = self.stream([conn])
                    if not processed_conn:
                        break
                    else:
                        processed_conn_list.append(processed_conn[0])
                traffic_matrix.at[i, j] = 0
            else:
                # case of finite request of capacity
                conn = Connection(i, j, 1)

                processed_conn = self.stream([conn], 'snr')

                df_counter = self.route_space == 'free'
                free_paths = df_counter.values.sum()

                if not processed_conn:
                    # connection not possible
                    traffic_matrix.at[i, j] = 0

                else:
                    processed_conn_list.append(processed_conn[0])

                    allocated_traffic = processed_conn[0].bit_rate

                    if allocated_traffic <= traffic_matrix.at[i, j]:
                        traffic_matrix.at[i, j] = traffic_matrix.at[i, j] - allocated_traffic
                    else:
                        traffic_matrix.at[i, j] = 0

                nonzero = traffic_matrix.to_numpy().nonzero()
                if len(nonzero[0]) == 0:
                    if processed_conn_list:
                        return [int(free_paths)] + [self.rejected_connections] + processed_conn_list
                    else:
                        return [int(free_paths)] + [self.rejected_connections]

        return [0]


class Connection:
    def __init__(self, input, output, signal_power):
        self.input: str = input
        self.output: str = output
        self.signal_power: float = signal_power
        self.latency: float = 0
        self.snr: float = 0
        self.gsnr: float = 0
        self.bit_rate = None

